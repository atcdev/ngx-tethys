{"version":3,"file":"dialog-container.component.js","sourceRoot":"","sources":["../../.tmp/dialog/dialog-container.component.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n    Component,\n    ChangeDetectionStrategy,\n    ComponentRef,\n    ViewChild,\n    EmbeddedViewRef,\n    ElementRef,\n    Inject,\n    EventEmitter,\n    ChangeDetectorRef,\n    HostBinding\n} from '@angular/core';\nimport {\n    ComponentPortal,\n    CdkPortalOutlet,\n    TemplatePortal\n} from '@angular/cdk/portal';\nimport { DOCUMENT } from '@angular/common';\nimport { AnimationEvent } from '@angular/animations';\nimport { ThyDialogConfig } from './dialog.config';\nimport { thyDialogAnimations } from './dialog-animations';\nimport { ThyClickPositioner } from '../core';\n\n@Component({\n    selector: 'thy-dialog-container',\n    template: `\n        <ng-template cdkPortalOutlet></ng-template>\n    `,\n    // Using OnPush for dialogs caused some sync issues, e.g. custom ngModel can't to detect changes\n    // Disabled until we can track them down.\n    changeDetection: ChangeDetectionStrategy.Default,\n    animations: [thyDialogAnimations.dialogContainer],\n    host: {\n        class: 'thy-dialog-container',\n        tabindex: '-1',\n        'aria-modal': 'true',\n        '[attr.id]': 'id',\n        '[attr.role]': 'config.role',\n        '[attr.aria-labelledby]': 'config.ariaLabel ? null : ariaLabelledBy',\n        '[attr.aria-label]': 'config.ariaLabel',\n        '[attr.aria-describedby]': 'config.ariaDescribedBy || null',\n        '[@dialogContainer]': 'animationState',\n        '(@dialogContainer.start)': 'onAnimationStart($event)',\n        '(@dialogContainer.done)': 'onAnimationDone($event)'\n    }\n})\nexport class ThyDialogContainerComponent {\n    @ViewChild(CdkPortalOutlet)\n    private portalOutlet: CdkPortalOutlet;\n\n    @HostBinding(`attr.id`)\n    id: string;\n\n    /** State of the dialog animation. */\n    animationState: 'void' | 'enter' | 'exit' = 'enter';\n\n    /** Emits when an animation state changes. */\n    animationStateChanged = new EventEmitter<AnimationEvent>();\n\n    /** ID of the element that should be considered as the dialog's label. */\n    ariaLabelledBy: string | null = null;\n\n    /** Element that was focused before the dialog was opened. Save this to restore upon close. */\n    private elementFocusedBeforeDialogWasOpened: HTMLElement | null = null;\n\n    private savePreviouslyFocusedElement() {\n        if (this.document) {\n            this.elementFocusedBeforeDialogWasOpened = this.document\n                .activeElement as HTMLElement;\n\n            // Note that there is no focus method when rendering on the server.\n            if (this.elementRef.nativeElement.focus) {\n                // Move focus onto the dialog immediately in order to prevent the user from accidentally\n                // opening multiple dialogs at the same time. Needs to be async, because the element\n                // may not be focusable immediately.\n                Promise.resolve().then(() =>\n                    this.elementRef.nativeElement.focus()\n                );\n            }\n        }\n    }\n\n    private restoreFocus() {\n        const toFocus = this.elementFocusedBeforeDialogWasOpened;\n\n        // We need the extra check, because IE can set the `activeElement` to null in some cases.\n        if (\n            this.config.restoreFocus &&\n            toFocus &&\n            typeof toFocus.focus === 'function'\n        ) {\n            toFocus.focus();\n        }\n\n        // if (this._focusTrap) {\n        //   this._focusTrap.destroy();\n        // }\n    }\n\n    private setTransformOrigin() {\n        this.clickPositioner.runTaskUseLastPosition(lastPosition => {\n            if (lastPosition) {\n                const containerElement: HTMLElement = this.elementRef\n                    .nativeElement;\n                const transformOrigin = `${lastPosition.x -\n                    containerElement.offsetLeft}px ${lastPosition.y -\n                    containerElement.offsetTop}px 0px`;\n                containerElement.style['transform-origin'] = transformOrigin;\n            }\n        });\n    }\n\n    constructor(\n        private elementRef: ElementRef,\n        @Inject(DOCUMENT) private document: any,\n        public config: ThyDialogConfig,\n        private changeDetectorRef: ChangeDetectorRef,\n        private clickPositioner: ThyClickPositioner\n    ) {}\n\n    /**\n     * Attach a ComponentPortal as content to this dialog container.\n     * @param portal Portal to be attached as the dialog content.\n     */\n    attachComponentPortal<T>(portal: ComponentPortal<T>): ComponentRef<T> {\n        if (this.portalOutlet.hasAttached()) {\n            throwThyDialogContentAlreadyAttachedError();\n        }\n\n        this.setTransformOrigin();\n        this.savePreviouslyFocusedElement();\n        return this.portalOutlet.attachComponentPortal(portal);\n    }\n\n    /**\n     * Attach a TemplatePortal as content to this dialog container.\n     * @param portal Portal to be attached as the dialog content.\n     */\n    attachTemplatePortal<C>(portal: TemplatePortal<C>): EmbeddedViewRef<C> {\n        if (this.portalOutlet.hasAttached()) {\n            throwThyDialogContentAlreadyAttachedError();\n        }\n\n        this.setTransformOrigin();\n        this.savePreviouslyFocusedElement();\n        return this.portalOutlet.attachTemplatePortal(portal);\n    }\n\n    /** Callback, invoked whenever an animation on the host completes. */\n    onAnimationDone(event: AnimationEvent) {\n        if (event.toState === 'enter') {\n            // this._trapFocus();\n        } else if (event.toState === 'exit') {\n            this.restoreFocus();\n        }\n\n        this.animationStateChanged.emit(event);\n    }\n\n    /** Callback, invoked when an animation on the host starts. */\n    onAnimationStart(event: AnimationEvent) {\n        this.animationStateChanged.emit(event);\n    }\n\n    startExitAnimation(): void {\n        this.animationState = 'exit';\n\n        // Mark the container for check so it can react if the\n        // view container is using OnPush change detection.\n        this.changeDetectorRef.markForCheck();\n    }\n}\n\nexport function throwThyDialogContentAlreadyAttachedError() {\n    throw Error(\n        'Attempting to attach dialog content after content is already attached'\n    );\n}\n"]}